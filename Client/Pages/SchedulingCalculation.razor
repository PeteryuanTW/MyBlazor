@page "/schedulingCalculation"
@using MyBlazor.Shared
@using MyBlazor.Shared.DataClass
@inject StateContainer stateContainer
@inject IToastService toastService
@inject NavigationManager navigationManager
<div class="container">
	<div class="row" style="align-items:center">
        <div class="col-auto">
            <button class="button @GABtnCss" @onclick="StartGA">Start Genetic Algo.</button>
        </div>
        <div class="col">
			<span style="position:absolute; left:50%; font-size:12px">@round/@stateContainer.GetIterations()</span>
            <progress class="progress is-warning" value=@round max="@stateContainer.GetIterations()"></progress>
        </div>
  </div>
</div>
<br>
<table class = "table table-striped table-sm" style="width:auto">
	<thead class="thead-light">
			<tr>
				<th>Visualize</th>
				<th>Log Time ID</th>
				<th>Duetime</th>
				<th>Job(s) Count</th>
			</tr>
	</thead>
	@foreach(SchedulingHistory schedulingHistory in stateContainer.GetSchedulingData())
	{
		<tr>
			<td>
				<button class="button is-primary is-rounded is-light" style="border:none" @onclick="(()=>
					{
						SchedulingHistory target = stateContainer.GetSchedulingHistoryByDateTimeString(schedulingHistory.dataTimeID);
						stateContainer.SetCurrentScheduling(target);
						GoToChart();
					})">
					<i class="oi oi-bar-chart"></i>
				</button>
			</td>
			<td>
				@schedulingHistory.dataTimeID
			</td>
			<td>
				@if (schedulingHistory.dueTime >= TimeSpan.Zero)
	            {
		            <label style="color:lawngreen">No duetime in this scheduling</label>
	            }
	            else
	            {
		            <label style="color:palevioletred">@schedulingHistory.dueTime.ToString("h'h 'm'm 's's'")</label>
	            }
			</td>
			<td>
				@schedulingHistory.woInfos.Count()
			</td>
		</tr>
	}
</table>

@code {
	private int round;
	private string GABtnCss = "";

	//static data
	private List<WORequirements> allWORequirements = new List<WORequirements>();
	private Dictionary<string, int> machineTypesAndCount = new Dictionary<string, int>();
	//best record
	private List<WoInfo> bestWOInfos = new List<WoInfo>();
	private TimeSpan bestDueTime = TimeSpan.MaxValue;
	//change when generate new gene
	private List<WORequirements> tmp_allWORequirements = new List<WORequirements>();
	private List<List<int>> machineSchedule = new List<List<int>>();
	private List<List<string>> flatSchedule = new List<List<string>>();
	private List<WoInfo> tmpWOInfos = new List<WoInfo>();
	private List<List<DateTime>> endTimes = new List<List<DateTime>>();
	protected override void OnInitialized()
	{

		base.OnInitialized();
	}

	protected override Task OnInitializedAsync()
	{
		round = stateContainer.GetCurrentRound();
		GABtnCss = stateContainer.GetGABtnCSS();

		stateContainer.OnCurrentRoundChange += GetCurrentRound;
		stateContainer.OnGABtnCssChange += GetGABtbCSS;
		GetWORequirements();
		return base.OnInitializedAsync();
	}

	public void Dispose()
	{
		stateContainer.OnCurrentRoundChange -= GetCurrentRound;
		stateContainer.OnGABtnCssChange -= GetGABtbCSS;
	}

	private void GoToChart()
	{
		navigationManager.NavigateTo("schedulingChart");
	}

	private void GetCurrentRound(int currentRound)
	{
		round = currentRound;
		StateHasChanged();
	}
	private void GetGABtbCSS(string newGABtnCss)
	{
		GABtnCss = newGABtnCss;
		StateHasChanged();
	}

	private async Task StartGA()
	{
		stateContainer.UIStartGA();
		for (int i = 0; i < stateContainer.GetIterations(); i++)
		{
			CopyRequirements();
			InitMachineSchedule();
			RandomAssignToMachine();
			ToFlatSchedule();
			FlatScheduleToInterval();
			stateContainer.SetCurrentRound(i+1);
			//Console.WriteLine(stateContainer.GetCurrentRound());
			await Task.Delay(1);
		}
		//stateContainer.SetWOInfos(bestWOInfos);
		//stateContainer.SetBsetDueTime(bestDueTime);
		SchedulingHistory newScheduling = new SchedulingHistory(DateTime.Now, bestWOInfos, bestDueTime);
		stateContainer.SetCurrentScheduling(newScheduling);
		stateContainer.AddSchedulingData(newScheduling);
		stateContainer.UIFinishGA();
		StateHasChanged();
		toastService.ShowSuccess("scheduling finished");
	}

	private void GetWORequirements()
	{
		allWORequirements = stateContainer.GetWORequirements();
	}
	private void CopyRequirements()
	{
		tmp_allWORequirements = new List<WORequirements>(allWORequirements);
		Shuffle(allWORequirements, 0, allWORequirements.Count - 1);
	}
	private void Shuffle<T>(IList<T> array, int first, int last)
	{
		Random r = new Random();
		for (int n = last; n >= last;)
		{
			int k = r.Next(n);
			--n;
			T temp = array[n+first];
			array[n + first] = array[k + first];
			array[k + first] = temp;
		}
	}
	private void InitMachineSchedule()
	{
		machineSchedule = new List<List<int>>();
		machineTypesAndCount = stateContainer.GetMachineTypeCount();
		for (int i = 0; i < machineTypesAndCount.Count; i++)
		{
			machineSchedule.Add(new List<int>());
			for (int j = 0; j < machineTypesAndCount.ElementAt(i).Value; j++)
			{
				machineSchedule[i].Add(0);
			}
		}

	}
	private void RandomAssignToMachine()
	{
		Random r = new Random();

		foreach (List<int> eachType in machineSchedule)
		{
			RandonPickMachine(eachType);
		}
	}
	private void RandonPickMachine(List<int> input)
	{
		Random r = new Random();
		int pickIndex = r.Next(0, input.Count);
		for (int i = 0; i < input.Count; i++)
		{
			if (i == pickIndex)
			{
				input[i] = 1;
			}
			else
			{
				input[i] = 0;
			}
		}
	}

	private void ToFlatSchedule()
	{
		flatSchedule = new List<List<string>>();
		for (int i = 0; i < tmp_allWORequirements.Count; i++)
		{
			flatSchedule.Add(new List<string>());
			flatSchedule[i].Add(tmp_allWORequirements[i].wo);

			for (int j = 0; j < tmp_allWORequirements[i].processCost.Count; j++)
			{
				InitMachineSchedule();
				RandomAssignToMachine();
				for (int k = 0; k < machineSchedule[j].Count; k++)
				{
					if (machineSchedule[j][k] == 0)
					{
						flatSchedule[i].Add("0");
					}
					else if (machineSchedule[j][k] == 1)
					{
						flatSchedule[i].Add(tmp_allWORequirements[i].processCost[j].ToString());
					}
				}
			}

			flatSchedule[i].Add(tmp_allWORequirements[i].dueTime.ToString());
		}
	}

	private void FlatScheduleToInterval()
	{
		DateTime scheduleStartTime = DateTime.Now;
		//init endtime list without wo and duetime
		int rows = flatSchedule.Count();
		int columns = flatSchedule[0].Count - 2;
		endTimes = new List<List<DateTime>>();
		tmpWOInfos = new List<WoInfo>();
		for (int i = 0; i < rows; i++)
		{
			List<DateTime> tmpRow = new List<DateTime>();
			for (int j = 0; j < columns; j++)
			{
				tmpRow.Add(scheduleStartTime);
			}
			endTimes.Add(tmpRow);
		}
		//end init
		for (int i = 0; i < flatSchedule.Count; i++)
		{
			for (int j = 1; j < flatSchedule[i].Count - 1; j++)
			{
				if (flatSchedule[i][j] != "0")
				{
					DateTime start = GetEndTimeFrom(scheduleStartTime, i, j, 0) > GetEndTimeFrom(scheduleStartTime, i, j, 1)? GetEndTimeFrom(scheduleStartTime, i, j, 0):GetEndTimeFrom(scheduleStartTime, i, j, 1);
					DateTime end = start + TimeSpan.Parse(flatSchedule[i][j]);
					endTimes[i][j-1] = end;
					tmpWOInfos.Add(new WoInfo(flatSchedule[i][0], stateContainer.GetMachineData()[j-1].machineName, stateContainer.GetMachineData()[j-1].index ,start, end));
				}
			}
		}

		if (GetDueTime(endTimes) < bestDueTime)
		{
			bestWOInfos = tmpWOInfos;
			bestDueTime = GetDueTime(endTimes);
		}

	}

	private TimeSpan GetDueTime(List<List<DateTime>> endTimes)
	{
		TimeSpan ts = TimeSpan.Zero;
		for (int i = 0; i< tmp_allWORequirements.Count; i++)
		{
            ts += (tmp_allWORequirements[i].dueTime - endTimes[i].Max());
		}
		return ts;
	}

	private DateTime GetEndTimeFrom(DateTime baseLine, int row, int col, int type)//0:last process, 1:machine
	{
		DateTime res = baseLine;
		if (type == 0)
		{
			for (int i = col - 1; i >= 0; i--)
			{
				if (endTimes[row][i] > baseLine)
				{
					res = endTimes[row][i];
					break;
				}
			}
		}
		else if (type == 1)
		{
			for (int i = row; i >= 0; i--)
			{
				if (endTimes[i][col-1] > baseLine)
				{
					res = endTimes[i][col-1];
					break;
				}
			}
		}
		return res;
	}
}
