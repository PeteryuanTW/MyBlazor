@page "/schedulingCalculation"
@using MyBlazor.Shared.DataClass
@using MyBlazor.Client.Service
@inject HttpClient httpClient
@inject StateContainer stateContainer

<button type="button" class="btn btn-warning" @onclick="@(()=>{
    
})">@a</button>

@code {
	//algo configs
	private int times = 10000;
	private int a = 0 ;
	//static data
	private List<WORequirements> allWORequirements = new List<WORequirements>();
	private Dictionary<string, int> machineTypesAndCount = new Dictionary<string, int>();
	//best record
	private List<WoInfo> bestWOInfos = new List<WoInfo>();
	private TimeSpan bestDueTime = TimeSpan.MaxValue;
	//change when generate new gene
	private List<WORequirements> tmp_allWORequirements = new List<WORequirements>();
	private List<List<int>> machineSchedule = new List<List<int>>();
	private List<List<string>> flatSchedule = new List<List<string>>();
	private List<WoInfo> tmpWOInfos = new List<WoInfo>();
	private List<List<DateTime>> endTimes = new List<List<DateTime>>();
	protected override void OnInitialized()
	{
		GetWORequirements();
		base.OnInitialized();
	}

	private async Task A()
	{
		await Task.Delay(new TimeSpan(0, 0, 5));
		a += 1;
	}

	private void StartGA()
	{
		for (int i = 0; i < times; i++)
		{
			CopyRequirements();
			InitMachineSchedule();
			RandomAssignToMachine();
			ToFlatSchedule();
			FlatScheduleToInterval();
			//a++;
			Console.WriteLine(i);
		}
		stateContainer.SetWOInfos(bestWOInfos);
		stateContainer.SetBsetDueTime(bestDueTime);
	}

	private void GetWORequirements()
	{
		allWORequirements = stateContainer.GetWORequirements();
	}
	private void CopyRequirements()
	{
		tmp_allWORequirements = new List<WORequirements>(allWORequirements);
		Shuffle(allWORequirements, 0, allWORequirements.Count - 1);
	}
	private void Shuffle<T>(IList<T> array, int first, int last)
	{
		Random r = new Random();
		for (int n = last; n >= last;)
		{
			int k = r.Next(n);
			--n;
			T temp = array[n+first];
			array[n + first] = array[k + first];
			array[k + first] = temp;
		}
	}
	private void InitMachineSchedule()
	{
		machineSchedule = new List<List<int>>();
		machineTypesAndCount = stateContainer.GetMachineTypeCount();
		for (int i = 0; i < machineTypesAndCount.Count; i++)
		{
			machineSchedule.Add(new List<int>());
			for (int j = 0; j < machineTypesAndCount.ElementAt(i).Value; j++)
			{
				machineSchedule[i].Add(0);
			}
		}

	}
	private void RandomAssignToMachine()
	{
		Random r = new Random();

		foreach (List<int> eachType in machineSchedule)
		{
			RandonPickMachine(eachType);
		}
	}
	private void RandonPickMachine(List<int> input)
	{
		Random r = new Random();
		int pickIndex = r.Next(0, input.Count);
		for (int i = 0; i < input.Count; i++)
		{
			if (i == pickIndex)
			{
				input[i] = 1;
			}
			else
			{
				input[i] = 0;
			}
		}
	}

	private void ToFlatSchedule()
	{
		flatSchedule = new List<List<string>>();
		for (int i = 0; i < tmp_allWORequirements.Count; i++)
		{
			flatSchedule.Add(new List<string>());
			flatSchedule[i].Add(tmp_allWORequirements[i].wo);

			for (int j = 0; j < tmp_allWORequirements[i].processCost.Count; j++)
			{
				InitMachineSchedule();
				RandomAssignToMachine();
				for (int k = 0; k < machineSchedule[j].Count; k++)
				{
					if (machineSchedule[j][k] == 0)
					{
						flatSchedule[i].Add("0");
					}
					else if (machineSchedule[j][k] == 1)
					{
						flatSchedule[i].Add(tmp_allWORequirements[i].processCost[j].ToString());
					}
				}
			}

			flatSchedule[i].Add(tmp_allWORequirements[i].dueTime.ToString());
		}
	}

	private void FlatScheduleToInterval()
	{
		DateTime scheduleStartTime = DateTime.Now;
		//init endtime list without wo and duetime
		int rows = flatSchedule.Count();
		int columns = flatSchedule[0].Count - 2;
		endTimes = new List<List<DateTime>>();
		tmpWOInfos = new List<WoInfo>();
		for (int i = 0; i < rows; i++)
		{
			List<DateTime> tmpRow = new List<DateTime>();
			for (int j = 0; j < columns; j++)
			{
				tmpRow.Add(scheduleStartTime);
			}
			endTimes.Add(tmpRow);
		}
		//end init
		for (int i = 0; i < flatSchedule.Count; i++)
		{
			for (int j = 1; j < flatSchedule[i].Count - 1; j++)
			{
				if (flatSchedule[i][j] != "0")
				{
					DateTime start = GetEndTimeFrom(scheduleStartTime, i, j, 0) > GetEndTimeFrom(scheduleStartTime, i, j, 1)? GetEndTimeFrom(scheduleStartTime, i, j, 0):GetEndTimeFrom(scheduleStartTime, i, j, 1);
					DateTime end = start + TimeSpan.Parse(flatSchedule[i][j]);
					endTimes[i][j-1] = end;
					tmpWOInfos.Add(new WoInfo(flatSchedule[i][0], stateContainer.GetMachineData()[j-1].machineName, stateContainer.GetMachineData()[j-1].index ,start, end));
				}
			}
		}

		if (GetDueTime(endTimes) < bestDueTime)
		{
			bestWOInfos = tmpWOInfos;
			bestDueTime = GetDueTime(endTimes);
		}

	}

	private TimeSpan GetDueTime(List<List<DateTime>> endTimes)
	{
		TimeSpan ts = TimeSpan.Zero;
		for (int i = 0; i< tmp_allWORequirements.Count; i++)
		{
            ts += (tmp_allWORequirements[i].dueTime - endTimes[i].Max());
		}
		return ts;
	}

	private DateTime GetEndTimeFrom(DateTime baseLine, int row, int col, int type)//0:last process, 1:machine
	{
		DateTime res = baseLine;
		if (type == 0)
		{
			for (int i = col - 1; i >= 0; i--)
			{
				if (endTimes[row][i] > baseLine)
				{
					res = endTimes[row][i];
					break;
				}
			}
		}
		else if (type == 1)
		{
			for (int i = row; i >= 0; i--)
			{
				if (endTimes[i][col-1] > baseLine)
				{
					res = endTimes[i][col-1];
					break;
				}
			}
		}
		return res;
	}
}
