@page "/schedulingCalculation"
@using MyBlazor.Shared
@using MyBlazor.Shared.DataClass
@inject StateContainer stateContainer
@inject IToastService toastService
@inject NavigationManager navigationManager
<div class="container">
	<div class="row" style="align-items:center">
        <div class="col-auto">
            <button class="button @GABtnCss" @onclick="StartGA">Start Genetic Algo.</button>
        </div>
        <div class="col">
			<span style="position:absolute; left:50%; font-size:12px">@round/@stateContainer.GetIterations()</span>
            <progress class="progress is-warning" value=@round max="@stateContainer.GetIterations()"></progress>
        </div>
  </div>
</div>
<br>
<table class = "table table-striped table-sm" style="width:auto">
	<thead class="thead-light">
			<tr>
				<th>Visualize</th>
				<th>Log Time ID</th>
				<th>Duetime</th>
				<th>Job(s) Count</th>
			</tr>
	</thead>
	@foreach(SchedulingHistory schedulingHistory in stateContainer.GetSchedulingData())
	{
		<tr>
			<td>
				<button class="button is-primary is-rounded is-light" style="border:none" @onclick="(()=>
					{
						SchedulingHistory target = stateContainer.GetSchedulingHistoryByDateTimeString(schedulingHistory.dataTimeID);
						stateContainer.SetCurrentScheduling(target);
						GoToChart();
					})">
					<i class="oi oi-bar-chart"></i>
				</button>
			</td>
			<td>
				@schedulingHistory.dataTimeID
			</td>
			<td>
				@if (schedulingHistory.dueTime >= TimeSpan.Zero)
	            {
					<label style="color:palevioletred">@schedulingHistory.dueTime.ToString("h'h 'm'm 's's'")</label>
	            }
	            else
	            {
		            <label style="color:lawngreen">No duetime in this scheduling</label>
	            }
			</td>
			<td>
				@schedulingHistory.jobsCount
			</td>
		</tr>
	}
</table>

@code {
	private int round;
	private string GABtnCss = "";

	//static data
	private List<WOJobs> allWOJobs = new();
	private Dictionary<string, int> machineTypesAndCount = new();
	private List<MachineTypeList> machineTypeLists = new();
	private List<int> typeJobsCount = new();
	private List<List<Job>> jobTypeMachineList = new();
	//dynamic programig
	private Dictionary<(string, string), DateTime> machineNextAvailable = new();
	private Dictionary<string, DateTime> woNextAvailable = new();
	//best record
	private List<List<Job>> bestJobs = new();
	private TimeSpan bestTime = TimeSpan.MaxValue;

	protected override void OnInitialized()
	{
		base.OnInitialized();
	}

	protected override Task OnInitializedAsync()
	{
		round = stateContainer.GetCurrentRound();
		GABtnCss = stateContainer.GetGABtnCSS();

		stateContainer.OnCurrentRoundChange += GetCurrentRound;
		stateContainer.OnGABtnCssChange += GetGABtbCSS;
		return base.OnInitializedAsync();
	}

	public void Dispose()
	{
		stateContainer.OnCurrentRoundChange -= GetCurrentRound;
		stateContainer.OnGABtnCssChange -= GetGABtbCSS;
	}

	private void GoToChart()
	{
		navigationManager.NavigateTo("schedulingChart");
	}

	private void GetCurrentRound(int currentRound)
	{
		round = currentRound;
		StateHasChanged();
	}
	private void GetGABtbCSS(string newGABtnCss)
	{
		GABtnCss = newGABtnCss;
		StateHasChanged();
	}

	private async Task StartGA()
	{
		stateContainer.UIStartGA();
		if (!CheckWOJobsAndMachine())
		{
			return;
		}
		InitWONextAvailable();
		machineTypeLists = stateContainer.GetMachineTable();

		for (int i = 0; i < stateContainer.GetIterations(); i++)
		{
			InitMachineNextAvailable();
			InitWONextAvailable();
			jobTypeMachineList = InitMachineBufferByJobs();
			AssignJobsToMachineBuffer();
			FillJobsTimes();
			if (CalculateDueTime(woNextAvailable) < bestTime)
			{
				bestTime = CalculateDueTime(woNextAvailable);
				bestJobs = jobTypeMachineList;
			}
			stateContainer.SetCurrentRound(i+1);
			await Task.Delay(1);
		}
		SchedulingHistory newScheduling = new SchedulingHistory(DateTime.Now, bestJobs, bestTime);
		stateContainer.SetCurrentScheduling(newScheduling);
		stateContainer.AddSchedulingData(newScheduling);

		stateContainer.UIFinishGA();
		StateHasChanged();
		toastService.ShowSuccess("scheduling finished");
	}

	private void InitMachineNextAvailable()
	{
		machineNextAvailable = new();
		foreach (MachineData machineData in stateContainer.GetMachineData())
		{
			machineNextAvailable.Add((machineData.machineName, machineData.index), machineData.nextAvailableTime);
		}
	}

	private void InitWONextAvailable()
	{
		woNextAvailable = new();
		foreach (WOJobs wojobs in stateContainer.GetWOJobs())
		{
			woNextAvailable.Add(wojobs.wo, DateTime.MinValue);
		}
	}

	private bool CheckWOJobsAndMachine()
	{
		allWOJobs = stateContainer.GetWOJobs().ToList<WOJobs>();//copy one from state container
		machineTypesAndCount = stateContainer.GetMachineTypeCount();
		foreach (WOJobs wo_jobs in allWOJobs)
		{
			if(wo_jobs.GetJobsCount() != machineTypesAndCount.Count)
			{
				return false;
			}
		}
		return true;
	}

	private List<List<Job>> InitMachineBufferByJobs()
	{
		List<List<Job>> res = new();
		typeJobsCount = new();
		for (int i = 0; i < allWOJobs[0].processCost.Count; i++)
		{
			int typeJobs = 0;//amount of each type of jobs
			for (int j = 0; j < allWOJobs.Count; j++)
			{
				if (allWOJobs[j].processCost[i] != TimeSpan.Zero)
				{
					typeJobs++;
				}
			}
			typeJobsCount.Add(typeJobs);
			int typeAmount = machineTypesAndCount.ElementAt(i).Value;
			res.Add(new List<Job>(new Job[typeJobs * typeAmount]));
		}
		return res;
	}

	private void AssignJobsToMachineBuffer()
	{
		for (int i = 0; i <  allWOJobs.Count; i++ )//get job from wo_job list
		{
			for (int j = 0; j < allWOJobs[i].processCost.Count; j++)//job types
			{
				if (allWOJobs[i].processCost[j] != TimeSpan.Zero)
				{
					int totalIndex;
					int index;
					do
					{
						totalIndex = jobTypeMachineList[j].Count;
						Random r = new Random();
						index = r.Next(0, totalIndex);
					} while (jobTypeMachineList[j][index] != null);
					jobTypeMachineList[j][index] = new Job(allWOJobs[i].wo, 0,allWOJobs[i].processCost[j]);
				}
			}

		}
	}

	private void FillJobsTimes()
	{
		for (int i = 0; i < jobTypeMachineList.Count; i++)
		{
			string type = machineTypeLists[i].machineType;
			int typeAmount = typeJobsCount[i];
			for (int j = 0; j < jobTypeMachineList[i].Count; j++)
			{
				if (jobTypeMachineList[i][j] != null)
				{
					int typeIndex = j / typeAmount;
					string index = machineTypeLists[i].machineIndexList[typeIndex];

					Job currentJob = jobTypeMachineList[i][j];
					currentJob.machine = type;
					currentJob.index = index;

					DateTime startAt = machineNextAvailable[(type, index)] > woNextAvailable[currentJob.wo] ? machineNextAvailable[(type, index)] : woNextAvailable[currentJob.wo];

					currentJob.SetStartTime(startAt);
					machineNextAvailable[(type, index)] = currentJob.end;
					woNextAvailable[currentJob.wo] = currentJob.end;

				}
			}
		}
	}
	private TimeSpan CalculateDueTime(Dictionary<string, DateTime> current_woNextAvailable)
	{
		TimeSpan res = TimeSpan.Zero;
		foreach (WOJobs woJob in allWOJobs)
		{
			DateTime expect = woJob.dueTime;
			DateTime actual = current_woNextAvailable[woJob.wo];
			if (actual > expect)
			{
				res += (actual - expect);
			}
		}
		return res;
	}
}
