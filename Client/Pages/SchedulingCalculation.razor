@page "/schedulingCalculation"
@using MyBlazor.Shared
@using MyBlazor.Shared.DataClass
@inject StateContainer stateContainer
@inject IToastService toastService
@inject NavigationManager navigationManager
<div class="container">
	<div class="row" style="align-items:center">
        <div class="col-auto">
            <button class="button @GABtnCss" @onclick="StartGA">Start Genetic Algo.</button>
        </div>
        <div class="col">
			<span style="position:absolute; left:50%; font-size:12px">@round/@stateContainer.GetIterations()</span>
            <progress class="progress is-warning" value=@round max="@stateContainer.GetIterations()"></progress>
        </div>
  </div>
</div>
<br>
<table class = "table table-striped table-sm" style="width:auto">
	<thead class="thead-light">
			<tr>
				<th>Visualize</th>
				<th>Log Time ID</th>
				<th>Duetime</th>
				<th>Job(s) Count</th>
			</tr>
	</thead>
	@foreach(SchedulingHistory schedulingHistory in stateContainer.GetSchedulingData())
	{
		<tr>
			<td>
				<button class="button is-primary is-rounded is-light" style="border:none" @onclick="(()=>
					{
						SchedulingHistory target = stateContainer.GetSchedulingHistoryByDateTimeString(schedulingHistory.dataTimeID);
						stateContainer.SetCurrentScheduling(target);
						GoToChart();
					})">
					<i class="oi oi-bar-chart"></i>
				</button>
			</td>
			<td>
				@schedulingHistory.dataTimeID
			</td>
			<td>
				@if (schedulingHistory.dueTime >= TimeSpan.Zero)
	            {
		            <label style="color:lawngreen">No duetime in this scheduling</label>
	            }
	            else
	            {
		            <label style="color:palevioletred">@schedulingHistory.dueTime.ToString("h'h 'm'm 's's'")</label>
	            }
			</td>
			<td>
				@schedulingHistory.woInfos.Count()
			</td>
		</tr>
	}
</table>

@code {
	private int round;
	private string GABtnCss = "";

	//static data
	private List<WOJobs> allWOJobs = new();
	private Dictionary<string, int> machineTypesAndCount = new();
	private List<MachineTypeList> machineTypeLists = new();
	private List<List<Job>> jobTypeMachineList = new();
	//best record
	private List<WoInfo> bestWOInfos = new List<WoInfo>();
	private TimeSpan bestDueTime = TimeSpan.MaxValue;
	//change when generate new gene
	private List<WOJobs> tmp_allWORequirements = new List<WOJobs>();
	private List<List<int>> machineSchedule = new List<List<int>>();
	private List<List<string>> flatSchedule = new List<List<string>>();
	private List<WoInfo> tmpWOInfos = new List<WoInfo>();
	private List<List<DateTime>> endTimes = new List<List<DateTime>>();
	protected override void OnInitialized()
	{
		base.OnInitialized();
	}

	protected override Task OnInitializedAsync()
	{
		round = stateContainer.GetCurrentRound();
		GABtnCss = stateContainer.GetGABtnCSS();

		stateContainer.OnCurrentRoundChange += GetCurrentRound;
		stateContainer.OnGABtnCssChange += GetGABtbCSS;
		//GetWORequirements();
		return base.OnInitializedAsync();
	}

	public void Dispose()
	{
		stateContainer.OnCurrentRoundChange -= GetCurrentRound;
		stateContainer.OnGABtnCssChange -= GetGABtbCSS;
	}

	private void GoToChart()
	{
		navigationManager.NavigateTo("schedulingChart");
	}

	private void GetCurrentRound(int currentRound)
	{
		round = currentRound;
		StateHasChanged();
	}
	private void GetGABtbCSS(string newGABtnCss)
	{
		GABtnCss = newGABtnCss;
		StateHasChanged();
	}

	private async Task StartGA()
	{
		stateContainer.UIStartGA();
		if (!CheckWOJobsAndMachine())
		{
			return;
		}
		machineTypeLists = stateContainer.GetMachineTable();
		jobTypeMachineList = InitMachineBufferByJobs();
		AssignJobsToMachineBuffer();

		/*
		for (int i = 0; i < stateContainer.GetIterations(); i++)
			{
			CopyRequirements();
			InitMachineSchedule();
			RandomAssignToMachine();
			ToFlatSchedule();
			FlatScheduleToInterval();
			stateContainer.SetCurrentRound(i+1);
			await Task.Delay(1);
		}
		SchedulingHistory newScheduling = new SchedulingHistory(DateTime.Now, bestWOInfos, bestDueTime);
		stateContainer.SetCurrentScheduling(newScheduling);
		stateContainer.AddSchedulingData(newScheduling);
		stateContainer.UIFinishGA();
		StateHasChanged();
		toastService.ShowSuccess("scheduling finished");
		*/
	}

	private bool CheckWOJobsAndMachine()
	{
		allWOJobs = stateContainer.GetWOJobs().ToList<WOJobs>();//copy one from state container
		machineTypesAndCount = stateContainer.GetMachineTypeCount();
		foreach (WOJobs wo_jobs in allWOJobs)
		{
			if(wo_jobs.GetJobsCount() != machineTypesAndCount.Count)
			{
				return false;
			}
		}
		return true;
	}

	private List<List<Job>> InitMachineBufferByJobs()
	{
		List<List<Job>> res = new();
		for (int i = 0; i < allWOJobs[0].processCost.Count; i++)
		{
			int typeJobs = 0;//amount of each type of jobs
			for (int j = 0; j < allWOJobs.Count; j++)
			{
				if (allWOJobs[j].processCost[i] != TimeSpan.Zero)
				{
					typeJobs++;
				}
			}
			int typeAmount = machineTypesAndCount.ElementAt(i).Value;
			res.Add(new List<Job>(new Job[typeJobs * typeAmount]));
		}
		return res;
	}

	private void AssignJobsToMachineBuffer()
	{
		for (int i = 0; i <  allWOJobs.Count; i++ )//get job from wo_job list
		{
			for (int j = 0; j < allWOJobs[i].processCost.Count; j++)//job types
			{
				if (allWOJobs[i].processCost[j] != TimeSpan.Zero)
				{
					int totalIndex;
					int index;
					do
					{
						totalIndex = jobTypeMachineList[j].Count;
						Random r = new Random();
						index = r.Next(0, totalIndex);
					} while (jobTypeMachineList[j][index] != null);
					jobTypeMachineList[j][index] = new Job(allWOJobs[i].wo, allWOJobs[i].processCost[j]);
				}
			}

		}
	}

	private void FillJobsTimes()
	{
		for (int i = 0; i < jobTypeMachineList.Count; i++)
		{
			int typeAmount = machineTypesAndCount.ElementAt(i).Value;
			for (int j = 0; j < jobTypeMachineList[i].Count; j += typeAmount)
			{
				for (int k = j; k < j + typeAmount; k++)
				{
					if (jobTypeMachineList[i][k] != null)
					{
						
					}
				}
			}
		}
	}

	private void InitMachineScheduleByJobs()
	{
		/*
		machineSchedule = new List<List<int>>();
		machineTypesAndCount = stateContainer.GetMachineTypeCount();
		for (int i = 0; i < machineTypesAndCount.Count; i++)
		{
			machineSchedule.Add(new List<int>());
			for (int j = 0; j < machineTypesAndCount.ElementAt(i).Value; j++)
			{
				machineSchedule[i].Add(0);
			}
		}*/

	}
	private void RandomAssignToMachine()
	{
		Random r = new Random();

		foreach (List<int> eachType in machineSchedule)
		{
			RandonPickMachine(eachType);
		}
	}
	private void RandonPickMachine(List<int> input)
	{
		int second = DateTime.Now.Millisecond;
		int pickIndex = second % input.Count;
		for (int i = 0; i < input.Count; i++)
		{
			if (i == pickIndex)
			{
				input[i] = 1;
			}
			else
			{
				input[i] = 0;
			}
		}
	}
	/*
	private void ToFlatSchedule()
	{
		flatSchedule = new List<List<string>>();
		for (int i = 0; i < tmp_allWORequirements.Count; i++)
		{
			flatSchedule.Add(new List<string>());
			flatSchedule[i].Add(tmp_allWORequirements[i].wo);

			for (int j = 0; j < tmp_allWORequirements[i].processCost.Count; j++)
			{
				InitMachineSchedule();
				RandomAssignToMachine();
				for (int k = 0; k < machineSchedule[j].Count; k++)
				{
					if (machineSchedule[j][k] == 0)
					{
						flatSchedule[i].Add("0");
					}
					else if (machineSchedule[j][k] == 1)
					{
						flatSchedule[i].Add(tmp_allWORequirements[i].processCost[j].ToString());
					}
				}
			}

			flatSchedule[i].Add(tmp_allWORequirements[i].dueTime.ToString());
		}
	}*/

	private void FlatScheduleToInterval()
	{
		DateTime scheduleStartTime = DateTime.Now;
		//init endtime list without wo and duetime
		int rows = flatSchedule.Count();
		int columns = flatSchedule[0].Count - 2;
		endTimes = new List<List<DateTime>>();
		tmpWOInfos = new List<WoInfo>();
		for (int i = 0; i < rows; i++)
		{
			List<DateTime> tmpRow = new List<DateTime>();
			for (int j = 0; j < columns; j++)
			{
				tmpRow.Add(scheduleStartTime);
			}
			endTimes.Add(tmpRow);
		}
		//end init

		for (int i = 0; i < flatSchedule.Count; i++)
		{
			for (int j = 1; j < flatSchedule[i].Count - 1; j++)
			{
				if (flatSchedule[i][j] != "0")
				{
					DateTime start = GetEndTimeFrom(scheduleStartTime, i, j, 0) > GetEndTimeFrom(scheduleStartTime, i, j, 1)? GetEndTimeFrom(scheduleStartTime, i, j, 0):GetEndTimeFrom(scheduleStartTime, i, j, 1);
					DateTime end = start + TimeSpan.Parse(flatSchedule[i][j]);
					endTimes[i][j-1] = end;
					tmpWOInfos.Add(new WoInfo(flatSchedule[i][0], stateContainer.GetMachineData()[j-1].machineName, int.Parse(stateContainer.GetMachineData()[j-1].index), 0, start, end));
				}
			}
		}

		if (GetDueTime(endTimes) < bestDueTime)
		{
			bestWOInfos = tmpWOInfos;
			bestDueTime = GetDueTime(endTimes);
		}

	}

	private TimeSpan GetDueTime(List<List<DateTime>> endTimes)
	{
		TimeSpan ts = TimeSpan.Zero;
		for (int i = 0; i< tmp_allWORequirements.Count; i++)
		{
            ts += (tmp_allWORequirements[i].dueTime - endTimes[i].Max());
		}
		return ts;
	}

	private DateTime GetEndTimeFrom(DateTime baseLine, int row, int col, int type)//0:last process, 1:machine
	{
		DateTime res = baseLine;
		if (type == 0)
		{
			for (int i = col - 1; i >= 0; i--)
			{
				if (endTimes[row][i] > baseLine)
				{
					res = endTimes[row][i];
					break;
				}
			}
		}
		else if (type == 1)
		{
			for (int i = row; i >= 0; i--)
			{
				if (endTimes[i][col-1] > baseLine)
				{
					res = endTimes[i][col-1];
					break;
				}
			}
		}
		return res;
	}
}
