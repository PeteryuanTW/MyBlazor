@page "/schedulingCalculation"
@using MyBlazor.Shared
@using MyBlazor.Shared.DataClass
@inject StateContainer stateContainer
@inject IToastService toastService
@inject NavigationManager navigationManager
<div class="container">
	<div class="row" style="align-items:center">
        <div class="col-auto">
            <button class="button @GABtnCss" @onclick="StartGA">Start Genetic Algo.</button>
        </div>
        <div class="col">
			<span style="position:absolute; left:50%; font-size:12px">@round/@stateContainer.GetIterations()</span>
            <progress class="progress is-warning" value=@round max="@stateContainer.GetIterations()"></progress>
        </div>
  </div>
</div>
<br>
<table class = "table table-striped table-sm" style="width:auto">
	<thead class="thead-light">
			<tr>
				<th>Visualize</th>
				<th>Log Time ID</th>
				<th>Duetime</th>
				<th>Job(s) Count</th>
			</tr>
	</thead>
	@foreach(SchedulingHistory schedulingHistory in stateContainer.GetSchedulingData())
	{
		<tr>
			<td>
				<button class="button is-primary is-rounded is-light" style="border:none" @onclick="(()=>
					{
						SchedulingHistory target = stateContainer.GetSchedulingHistoryByDateTimeString(schedulingHistory.dataTimeID);
						stateContainer.SetCurrentScheduling(target);
						GoToChart();
					})">
					<i class="oi oi-bar-chart"></i>
				</button>
			</td>
			<td>
				@schedulingHistory.dataTimeID
			</td>
			<td>
				@if (schedulingHistory.dueTime >= TimeSpan.Zero)
	            {
					<label style="color:palevioletred">@schedulingHistory.dueTime.ToString("h'h 'm'm 's's'")</label>
	            }
	            else
	            {
		            <label style="color:lawngreen">No duetime in this scheduling</label>
	            }
			</td>
			<td>
				@schedulingHistory.jobsCount
			</td>
		</tr>
	}
</table>

@code {
	private int round;
	private string GABtnCss = "";

	//static data without rescheduling
	private List<WOJobs> allWOJobs = new();
	private Dictionary<string, int> machineTypesAndCount = new();
	private List<MachineTypeList> machineTypeLists = new();
	private List<int> typeJobsCount = new();
	//complete after scheduling
	private List<List<Job>> jobTypeMachineList = new();
	//dynamic programig
	private Dictionary<(string, string), DateTime> machineNextAvailable = new();
	private Dictionary<string, DateTime> woNextAvailable = new();

	//history date record
	private List<List<Job>> bestJobs = new();
	private TimeSpan bestTime = TimeSpan.MaxValue;
	private Dictionary<(string, string), DateTime> bestMachineNextAvailable = new();
	private Dictionary<string, DateTime> bestWONextAvailable = new();

	protected override void OnInitialized()
	{
		base.OnInitialized();
	}

	protected override Task OnInitializedAsync()
	{
		round = stateContainer.GetCurrentRound();
		GABtnCss = stateContainer.GetGABtnCSS();

		stateContainer.OnCurrentRoundChange += GetCurrentRound;
		stateContainer.OnGABtnCssChange += GetGABtbCSS;
		return base.OnInitializedAsync();
	}

	public void Dispose()
	{
		stateContainer.OnCurrentRoundChange -= GetCurrentRound;
		stateContainer.OnGABtnCssChange -= GetGABtbCSS;
	}

	private void GoToChart()
	{
		navigationManager.NavigateTo("schedulingChart");
	}

	private void GetCurrentRound(int currentRound)
	{
		round = currentRound;
		StateHasChanged();
	}
	private void GetGABtbCSS(string newGABtnCss)
	{
		GABtnCss = newGABtnCss;
		StateHasChanged();
	}

	//algo
	private async Task StartGA()
	{
		stateContainer.UIStartGA();
		if (!CheckWOJobsAndMachine())
		{
			return;
		}
		InitWONextAvailable();
		machineTypeLists = stateContainer.GetMachineTable();

		for (int i = 0; i < stateContainer.GetIterations(); i++)
		{
			InitMachineNextAvailable();
			InitWONextAvailable();
			jobTypeMachineList = InitMachineBufferByJobs();
			GenericAlgo.AssignJobsToMachineBuffer(allWOJobs, ref jobTypeMachineList);
			GenericAlgo.FillJobsTimes(ref jobTypeMachineList, machineTypeLists, typeJobsCount, ref machineNextAvailable, ref  woNextAvailable);
			TimeSpan newTime = GenericAlgo.CalculateDueTime(allWOJobs, woNextAvailable);
			if (newTime < bestTime)
			{
				bestTime = newTime;
				bestJobs = jobTypeMachineList;
				bestMachineNextAvailable = machineNextAvailable;
				bestWONextAvailable = woNextAvailable;
			}
			stateContainer.SetCurrentRound(i+1);
			await Task.Delay(1);
		}
		SchedulingHistory newScheduling = new SchedulingHistory(DateTime.Now, bestJobs, bestTime, bestMachineNextAvailable, bestWONextAvailable);
		stateContainer.SetCurrentScheduling(newScheduling);
		stateContainer.AddSchedulingData(newScheduling);

		stateContainer.UIFinishGA();
		StateHasChanged();
		toastService.ShowSuccess("scheduling finished");
	}

	private void InitMachineNextAvailable()
	{
		machineNextAvailable = new();
		foreach (MachineData machineData in stateContainer.GetMachineData())
		{
			machineNextAvailable.Add((machineData.machineName, machineData.index), machineData.nextAvailableTime);
		}
	}

	private void InitWONextAvailable()
	{
		woNextAvailable = new();
		foreach (WOJobs wojobs in stateContainer.GetWOJobs())
		{
			woNextAvailable.Add(wojobs.wo, DateTime.MinValue);
		}
	}

	private bool CheckWOJobsAndMachine()
	{
		allWOJobs = stateContainer.GetWOJobs().ToList<WOJobs>();//copy one from state container
		machineTypesAndCount = stateContainer.GetMachineTypeCount();
		foreach (WOJobs wo_jobs in allWOJobs)
		{
			if(wo_jobs.GetJobsCount() != machineTypesAndCount.Count)
			{
				return false;
			}
		}
		return true;
	}

	private List<List<Job>> InitMachineBufferByJobs()
	{
		List<List<Job>> res = new();
		typeJobsCount = new();
		for (int i = 0; i < allWOJobs[0].processCost.Count; i++)
		{
			int typeJobs = 0;//amount of each type of jobs
			for (int j = 0; j < allWOJobs.Count; j++)
			{
				if (allWOJobs[j].processCost[i] != TimeSpan.Zero)
				{
					typeJobs++;
				}
			}
			typeJobsCount.Add(typeJobs);
			int typeAmount = machineTypesAndCount.ElementAt(i).Value;
			List<Job> tmp =  Enumerable.Repeat(new Job(), typeJobs * typeAmount).ToList();
			res.Add(tmp);
		}
		return res;
	}
}
