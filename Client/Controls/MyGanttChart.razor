@using MyBlazor.Shared.DataClass

<label class="oi oi-map-marker" style="font-size:15px; text-align:center; margin-left:20px" text-align:center"></label>
@if (woinfos != null)
{
	<label style="font-size:20px; text-align:center; margin-left:15px">@dateTimeID.ToString("yyyy/MM/dd HH:mm:ss")</label>
	<br>
}
@if(minTime!=maxTime)
{
	<label style="font-size:25px; text-align:center; margin-left:20px">@minTime.ToString("yyyy MM/dd hh:mm:ss")</label>
	<label class="oi oi-chevron-right" style="font-size:20px; text-align:center; margin-left:20px"></label>
	<label style="font-size:25px; text-align:center; margin-left:20px">@maxTime.ToString("yyyy MM/dd hh:mm:ss")</label>
}
<table class="table is-bordered">
	<tbody>
		@foreach(MachineWOInfos machineWOInfo in machineWOInfos)
		{
			<tr>
				<td class="is-narrow border-0">
					<Machine machineName="@machineWOInfo.machineName" index="@machineWOInfo.index" machineStatus="@machineWOInfo.machineStatus"></Machine>
				</td>
				<td class="is-narrow border-0">
					<Capacity allWO="machineWOInfo.woAndTimes"></Capacity>
				</td>
				<td>
					@if (tmp_margin != 0.0f || tmp_width!=0.0f)
					{
						tmp_margin = 0.0f;
						tmp_width = 0.0f;
					}
					@foreach(WOAndTimes woAndTime in machineWOInfo.woAndTimes)
					{
						<MyGanttBar woStatus = "@woAndTime.woStatus"
						             wo="@woAndTime.wo"
						             startTime="@woAndTime.startAndEndTime.startTime"
									 endTime="@woAndTime.startAndEndTime.endTime"
									 startPositionPercent="@GetStartPosition(@woAndTime.startAndEndTime.startTime)"
									 widthPercent="@GetWidth(@woAndTime.startAndEndTime.startTime, @woAndTime.startAndEndTime.endTime)"
						>
						</MyGanttBar>
						tmp_margin += (@GetStartPosition(@woAndTime.startAndEndTime.startTime)+tmp_width);
						tmp_width = @GetWidth(@woAndTime.startAndEndTime.startTime, @woAndTime.startAndEndTime.endTime);
					}
				</td>
			</tr>
		}
		<tr>
			<td  class="border-0"></td>
			<td  class="border-0"></td>
			<td  class="border-0">
				<GanttTimeLine start=@minTime end=@maxTime></GanttTimeLine>
			</td>
		</tr>
	</tbody>
</table>
@if (bestDueTime != TimeSpan.Zero)
{
	if (bestDueTime >= TimeSpan.Zero)
	{
		<label style="font-size:25px; color:lawngreen; text-align:center; margin-left:20px">No duetime in this scheduling</label>
	}
	else
	{
		<label style="font-size:25px; text-align:center; margin-left:20px">Delay:</label>
		<label style="font-size:25px; color:palevioletred; text-align:center; margin-left:20px">@bestDueTime.ToString("h'h 'm'm 's's'")</label>
	}
}
<div style="margin-top:20px; margin-left:20px">
	<button class="button is-info is-rounded is-light" style="border:none" @onclick="(()=>{showAddWODiakogue = true;})">
	    <i class="oi oi-plus"></i>
    </button>
</div>


@if (showAddWODiakogue)
{
	<AddWODialogue display="displayHandler" ECInsertTime="NewWOHandler"></AddWODialogue>
}



@code {
	[Parameter]
	public List<MachineData> allMachineStatus { get; set; } = new List<MachineData>();//only machine
	[Parameter]
	public List<MachineWOInfos> machineWOInfos { get; set;}= new List<MachineWOInfos>();//group by machine
	[Parameter]
	public MachineWOInfos? targetMachineInfos { get; set; }
	[Parameter]
	public DateTime dateTimeID { get; set; }
	[Parameter]
	public List<WoInfo> woinfos{ get; set; } = new List<WoInfo>();//detail
	[Parameter]
	public TimeSpan bestDueTime { get; set; } = TimeSpan.Zero;
	public float tmp_margin { get; set; } = 0.0f;
	public float tmp_width { get; set; } = 0.0f;

	protected override Task OnParametersSetAsync()
	{
		InitMachine();
		if (woinfos != null)
		{
			InitWoInfo();
		}
		StateHasChanged();
		return base.OnParametersSetAsync();
	}

	private void InitMachine()
	{
		machineWOInfos.Clear();
		for(int i = 0; i <allMachineStatus.Count; i++)
		{
			machineWOInfos.Add(new MachineWOInfos(allMachineStatus[i].machineName, int.Parse(allMachineStatus[i].index) ,allMachineStatus[i].machineStatus, new List<WOAndTimes>()));
		}
	}

	private void InitWoInfo()
	{
		foreach (WoInfo woinfo in woinfos)
		{
			var targetMachine = machineWOInfos.Find(x=>x.machineName == woinfo.machine && x.index == woinfo.index);
			if (targetMachine != null)
			{
				var targetWO = targetMachine.woAndTimes.Find(x => x.wo == woinfo.wo);
				if (targetWO != null)
				{
					targetWO.woStatus = woinfo.generateType;
				}
				else
				{
					targetMachine.woAndTimes.Add(new WOAndTimes(woinfo.wo, woinfo.generateType, new StartTimeAndEndTime(woinfo.t.startTime, woinfo.t.endTime)));
				}
			}
		}
		foreach(MachineWOInfos woList in machineWOInfos)
		{
			woList.Sort();
		}
		GetMaxAndMinTimeInterval();
	}

	bool showAddWODiakogue = false;
	void displayHandler(bool display)
	{
		showAddWODiakogue=display;
	}
	void machineClickHandler((string targetMachine, int index) machineAndIndex)
	{
		targetMachineInfos = machineWOInfos.Find(x => x.machineName ==  machineAndIndex.targetMachine&& x.index == machineAndIndex.index);
		showAddWODiakogue = true;
	}

	void NewWOHandler(DateTime insertTime)
	{
		foreach(WoInfo woinfo in woinfos)
		{
			if (woinfo.t.startTime >= insertTime)
			{
				woinfo.generateType = 1;
			}
		}
		InitWoInfo();
	}


	//calculate position function
	#region
	public DateTime minTime { get; set; } = DateTime.Now;
	public DateTime maxTime { get; set; } = DateTime.Now;
	List<DateTime> allTimes = new List<DateTime>();
	TimeSpan interval = TimeSpan.Zero;
	private void GetMaxAndMinTimeInterval()
	{
		allTimes.Clear();
		foreach (MachineWOInfos machineWOInfos in machineWOInfos)
		{
			foreach (WOAndTimes woAndTime in machineWOInfos.woAndTimes)
			{
				allTimes.Add(woAndTime.startAndEndTime.startTime);
				allTimes.Add(woAndTime.startAndEndTime.endTime);

			}
		}
		if (allTimes.Count != 0)
		{
			DateTime tmp_minTime = allTimes.Min();
		    DateTime tmp_maxTime = allTimes.Max();
		    minTime = new DateTime(tmp_minTime.Year, tmp_minTime.Month, tmp_minTime.Day, tmp_minTime.Hour, 0, 0, 0);
		    maxTime = new DateTime(tmp_maxTime.Year, tmp_maxTime.Month, tmp_maxTime.Day, tmp_maxTime.Hour+1, 0, 0, 0);
		    interval = maxTime - minTime;
		}

	}

	private float GetStartPosition(DateTime startTime)
	{
		float res = 0.0f;
		TimeSpan distance = startTime - minTime;
		res = (float)(distance / interval);
		//set position: relative for width is necessary
		//so need to deduct the margin and width of pervious bar
		return res*100-tmp_margin-tmp_width;
	}
	private float GetWidth(DateTime startTime, DateTime endTime)
	{
		float res = 0.0f;
		TimeSpan thisInterval = endTime - startTime;
		res = (float)(thisInterval / interval);
		return res*100;
	}
	#endregion


}
