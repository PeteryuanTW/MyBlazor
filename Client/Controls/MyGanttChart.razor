<div>start at: @minTime, end at: @maxTime</div>
<div>minima duetime: @bestDueTime</div>
<table class="table is-bordered">
	<tbody>
		@foreach(MachineWOInfos machineWOInfo in machineWOInfos)
		{
			<tr>
				<td class="is-narrow border-0">
					<Machine machineName="@machineWOInfo.machineName" index="@machineWOInfo.index" machineStatus="@machineWOInfo.machineStatus" getClickMachine="machineClickHandler"></Machine>
				</td>
				<td class="is-narrow border-0">
					<Capacity allWO="machineWOInfo.woAndTimes"></Capacity>
				</td>
				<td>
					@if (tmp_margin != 0.0f || tmp_width!=0.0f)
					{
						tmp_margin = 0.0f;
						tmp_width = 0.0f;
					}
					@foreach(WOAndTimes woAndTime in machineWOInfo.woAndTimes)
					{
						<MyGanttBar woStatus = "@woAndTime.woStatus"
						             wo="@woAndTime.wo"
						             startTime="@woAndTime.startAndEndTime.startTime"
									 endTime="@woAndTime.startAndEndTime.endTime"
									 startPositionPercent="@GetStartPosition(@woAndTime.startAndEndTime.startTime)"
									 widthPercent="@GetWidth(@woAndTime.startAndEndTime.startTime, @woAndTime.startAndEndTime.endTime)"
						>
						</MyGanttBar>
						tmp_margin += (@GetStartPosition(@woAndTime.startAndEndTime.startTime)+tmp_width);
						tmp_width = @GetWidth(@woAndTime.startAndEndTime.startTime, @woAndTime.startAndEndTime.endTime);
					}
				</td>
			</tr>
		}
		<tr>
			<td  class="border-0"></td>
			<td  class="border-0"></td>
			<td  class="border-0">
				<GanttTimeLine start=@minTime end=@maxTime></GanttTimeLine>
			</td>
		</tr>
	</tbody>
</table>

@if (showAddWODiakogue)
{
	<AddWODialogue display="displayHandler" EC_newWO="NewWOHandler" currentMachineInfos=@targetMachineInfos></AddWODialogue>
}



@code {
	[Parameter]
	public TimeSpan bestDueTime { get; set; } = TimeSpan.Zero;
	[Parameter]
	public List<MachineData> allMachineStatus { get; set; } = new List<MachineData>();//only machine
	[Parameter]
	public List<MachineWOInfos> machineWOInfos { get; set;}= new List<MachineWOInfos>();//group by machine
	[Parameter]
	public MachineWOInfos? targetMachineInfos { get; set; }
	[Parameter]
	public List<WoInfo> woinfos{ get; set; } = new List<WoInfo>();//detail
	public float tmp_margin { get; set; } = 0.0f;
	public float tmp_width { get; set; } = 0.0f;

	protected override Task OnInitializedAsync()
	{
		for(int i = 0; i <allMachineStatus.Count; i++)
		{
			machineWOInfos.Add(new MachineWOInfos(allMachineStatus[i].machineName, allMachineStatus[i].index ,allMachineStatus[i].machineStatus, new List<WOAndTimes>()));
		}
		InitWoInfo();
		return base.OnInitializedAsync();
	}

	private void InitWoInfo()
	{
		foreach (WoInfo woinfo in woinfos)
		{
			var targetMachine = machineWOInfos.Find(x=>x.machineName == woinfo.machine && x.index == woinfo.index);
			if (targetMachine != null)
			{
				targetMachine.woAndTimes.Add(new WOAndTimes(woinfo.wo, 0, new StartTimeAndEndTime(woinfo.t.startTime, woinfo.t.endTime)));
			}
		}
		foreach(MachineWOInfos woList in machineWOInfos)
		{
			woList.Sort();
		}
		GetMaxAndMinTimeInterval();
	}

	bool showAddWODiakogue = false;
	void displayHandler(bool display)
	{
		showAddWODiakogue=display;
	}
	void machineClickHandler(string targetMachine)
	{
		targetMachineInfos = machineWOInfos.Find(x => x.machineName == targetMachine);
		showAddWODiakogue = true;
	}

	void NewWOHandler(MachineWOInfos newInfos)
	{
		machineWOInfos.Find(x => x.machineName == newInfos.machineName).woAndTimes = newInfos.woAndTimes;
		foreach(MachineWOInfos woList in machineWOInfos)
		{
			woList.Sort();
		}
		GetMaxAndMinTimeInterval();
	}
	//calculate position function
	#region
	public DateTime minTime { get; set; } = DateTime.Now;
	public DateTime maxTime { get; set; } = DateTime.Now;
	List<DateTime> allTimes = new List<DateTime>();
	TimeSpan interval = TimeSpan.Zero;
	private void GetMaxAndMinTimeInterval()
	{
		allTimes.Clear();
		foreach (MachineWOInfos machineWOInfos in machineWOInfos)
		{
			foreach (WOAndTimes woAndTime in machineWOInfos.woAndTimes)
			{
				allTimes.Add(woAndTime.startAndEndTime.startTime);
				allTimes.Add(woAndTime.startAndEndTime.endTime);

			}
		}
		if (allTimes.Count != 0)
		{
			DateTime tmp_minTime = allTimes.Min();
		    DateTime tmp_maxTime = allTimes.Max();
		    minTime = new DateTime(tmp_minTime.Year, tmp_minTime.Month, tmp_minTime.Day, tmp_minTime.Hour, 0, 0, 0);
		    maxTime = new DateTime(tmp_maxTime.Year, tmp_maxTime.Month, tmp_maxTime.Day, tmp_maxTime.Hour+1, 0, 0, 0);
		    interval = maxTime - minTime;
		}

	}

	private float GetStartPosition(DateTime startTime)
	{
		float res = 0.0f;
		TimeSpan distance = startTime - minTime;
		res = (float)(distance / interval);
		//set position: relative for width is necessary
		//so need to deduct the margin and width of pervious bar
		return res*100-tmp_margin-tmp_width;
	}
	private float GetWidth(DateTime startTime, DateTime endTime)
	{
		float res = 0.0f;
		TimeSpan thisInterval = endTime - startTime;
		res = (float)(thisInterval / interval);
		return res*100;
	}
	#endregion


}
